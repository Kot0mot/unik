Вариант 10 — Генерация всех бинарных строк длины n — Анализ сложности
Реализована рекурсивная функция, которая выводит все возможные бинарные строки длины n, состоящие из символов ‘0’ и ‘1’. Функция использует подход backtracking: на каждом шаге добавляется ‘0’ или ‘1’, пока не будет достигнута нужная длина.
def generate_binary_strings(n, current=""):
    if len(current) == n:
        print(current)
        return
    generate_binary_strings(n, current + "0")
    generate_binary_strings(n, current + "1")

# Тест
n = 3
print(f"Все бинарные строки длины {n}:")
generate_binary_strings(n)
При n = 3 вывод:
Все бинарные строки длины 3:
000
001
010
011
100
101
110
111



Базовый случай — строка достигла длины n, тогда она выводится и рекурсия завершается. Проверка длины и вывод выполняются за O(n).
Рекурсивный случай — к текущей строке добавляется ‘0’ и ‘1’, и функция вызывается дважды. Конкатенация строки в Python требует O(k) времени, где k — текущая длина строки, из-за неизменяемости строк.
Глубина рекурсии равна n — от пустой строки до строки длины n. На каждом уровне k (от 0 до n−1) создаётся 2^k узлов, и на каждом узле выполняется конкатенация длины k+1. Суммарная стоимость конкатенаций: O(1·2^0 + 2·2^1 + 3·2^2 + … + (n−1)·2^{n−1}) = O(n · 2^n).
Кроме того, на листьях (2^n строк) выполняется вывод, каждый за O(n), что даёт ещё O(n · 2^n).

Временная сложность: O(n · 2^n)
Это оптимально, так как нужно вывести 2^n строк длины n, и объём вывода составляет n · 2^n. Быстрее невозможно.

Пространственная сложность: O(n)
Максимальная глубина стека — n, плюс текущая строка длины до n.

Вывод
Алгоритм использует рекурсивный backtracking и оптимален по времени — нельзя сгенерировать и вывести 2^n строк быстрее, чем за O(n · 2^n). Память используется эффективно: O(n). Для больших n (> 30) рекомендуется итеративный подход или генераторы, чтобы избежать переполнения стека.


Контрольный вопрос №1
Что такое рекурсия? Приведите пример базового и рекурсивного случая.
Рекурсия — это метод, при котором функция вызывает саму себя для решения задачи, разбивая её на более простые подзадачи. Состоит из двух частей: базового случая и рекурсивного случая.
Базовый случай — условие, при котором функция возвращает результат без рекурсивных вызовов. Он предотвращает бесконечную рекурсию.
Рекурсивный случай — функция вызывает себя с изменёнными параметрами, приближая к базовому случаю.
Пример: факториал
def factorial(n):
    # Базовый случай
    if n == 0 or n == 1:
        return 1
    # Рекурсивный случай
    return n * factorial(n - 1)
Базовый случай: n = 0 или 1 → возврат 1
Рекурсивный случай: n * factorial(n−1) → вызов с уменьшенным аргументом
Без базового случая рекурсия бесконечна и вызывает переполнение стека.
